 start = COSE_Messages
; / COSE_Key / COSE_KeySet
  / Internal_Types

Internal_Types = Sig_structure ; / Enc_structure / MAC_structure

label = int / tstr
values = any

COSE_Messages = COSE_Untagged_Message / COSE_Tagged_Message

COSE_Untagged_Message = COSE_Sign / COSE_Sign1 ; /
;    COSE_Encrypt / COSE_Encrypt0 /
;    COSE_Mac / COSE_Mac0

COSE_Tagged_Message = COSE_Sign_Tagged / COSE_Sign1_Tagged ; /
;    COSE_Encrypt_Tagged / COSE_Encrypt0_Tagged /
;    COSE_Mac_Tagged / COSE_Mac0_Tagged

Headers = (
    protected : empty_or_serialized_map,
    unprotected : header_map
)

; I need to define Generic_Headers first, because if a name appears
; as a group element first, there is no way to determine whether it is
; a typename or a groupname

; Also, I replaced `=>` with `:` (to avoid the pattern described in
; RFC 8610 Section 3.5.4; this is likely a COSE spec bug)

; Also, I introduced a CDDL constant type, `everparse-no-match`, to
; model empty types. This is sufficient to model the fact that keys 5
; and 6 shall not appear together

Generic_Headers = (
  ? 1 : int / tstr,  ; algorithm identifier
  ? 2 : [+label],    ; criticality
  ? 3 : tstr / int,  ; content type
  ? 4 : bstr,        ; key identifier
  ((5 => bstr, ? 6 : everparse-no-match) // (6 => bstr, ? 5 : everparse-no-match))
)

header_map = {
   Generic_Headers,
    * label => values
}

empty_or_serialized_map = bstr ; TODO: .cbor header_map / bstr .size 0

COSE_Sign_Tagged = #6.98(COSE_Sign)

COSE_Sign = [
    Headers,
    payload : bstr / nil,
    signatures : [+ COSE_Signature]
]

COSE_Signature =  [
    Headers,
    signature : bstr
]

COSE_Sign1_Tagged = #6.18(COSE_Sign1)

COSE_Sign1 = [
    Headers,
    payload : bstr / nil,
    signature : bstr
]

; FIXME: This CDDL specification is buggy with the greedy semantics
; for `?`: even if `sign_protected` is not required, `external_aad`
; will require a bstr, which will be caught by `?sign_protected`.

; Sig_structure = [
;     context : "Signature" / "Signature1",
;     body_protected : empty_or_serialized_map,
;     ? sign_protected : empty_or_serialized_map,
;     external_aad : bstr,
;     payload : bstr
; ]

; To circumvent this bug, we need to rewrite the specification as
; follows:

Sig_structure = [
    context : "Signature" / "Signature1",
    body_protected : empty_or_serialized_map,
    (
        sign_protected : empty_or_serialized_map,
        external_aad : bstr,
        payload : bstr
     //
        external_aad : bstr,
        payload : bstr
    )
]
